<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

<!-- Visualisation of 1+1 spacetime -->

var graphs;
var trajectories;
var g;
var time_range;
var space_range;
var isDragging;

// classes:

function pos(x, y) {
    return { x:x, y:y };
}

function rect(x, y, width, height) {
    return { x:x, y:y, width:width, height:height };
}

function range(min, max, step=1.0) {
    return { min:min, max:max, step:step };
}

function trajectory(start, end, color) {
    return { start:start, end:end, color:color };
}

function graph(rect, frame_acceleration) {
    return {rect:rect, frame_acceleration:frame_acceleration, transform:findBestFitTransform(rect, frame_acceleration)};
}

function linearTransform(mult_x, offset_x, mult_y, offset_y) {
    return { mult_x:mult_x, offset_x:offset_x, mult_y:mult_y, offset_y:offset_y };
}

// functions:

function lerp(a, b, u) {
    return pos(a.x + u*(b.x-a.x), a.y + u*(b.y-a.y));
}

function moveTo(p) {
    ctx.moveTo(p.x, p.y);
}

function lineTo(p) {
    ctx.lineTo(p.x, p.y);
}

// adapted from http://stackoverflow.com/a/6333775/126823
function drawArrowHead( a, b, size ) { 
    var angle = Math.atan2(b.y-a.y,b.x-a.x);
    ctx.beginPath();
    ctx.moveTo(b.x - size * Math.cos(angle - Math.PI/6), b.y - size * Math.sin(angle - Math.PI/6));
    ctx.lineTo(b.x, b.y);
    ctx.lineTo(b.x - size * Math.cos(angle + Math.PI/6), b.y - size * Math.sin(angle + Math.PI/6));
    ctx.stroke();
}

function applyLinearTransform(p, transform) {
    return pos(transform.offset_x + transform.mult_x * p.x, transform.offset_y + transform.mult_y * p.y);
}

function applyLinearTransformInverse(p, transform) {
    return pos((p.x - transform.offset_x) / transform.mult_x, (p.y - transform.offset_y) / transform.mult_y);
}

function computeLinearTransform(from_rect, to_rect) {
    mult_x = to_rect.width / from_rect.width;
    offset_x = to_rect.x - mult_x * from_rect.x;
    mult_y = to_rect.height / from_rect.height;
    offset_y = to_rect.y - mult_y * from_rect.y;
    return linearTransform(mult_x, offset_x, mult_y, offset_y);
}

function boundingRect(points) {
    var left = Number.MAX_VALUE;
    var right = -Number.MAX_VALUE;
    var top = Number.MAX_VALUE;
    var bottom = -Number.MAX_VALUE;
    for(var i = 0; i < points.length; i++) {
        left = Math.min(left, points[i].x);
        right = Math.max(right, points[i].x);
        top = Math.min(top, points[i].y);
        bottom = Math.max(bottom, points[i].y);
    }
    return rect(left, top, right-left, bottom-top);
}

function onMouseMove( evt ) {
}

function onTouchMove( evt ) {
}

function onTouchStart( evt ) {
}

function onMouseDown( evt ) {
    var p = getMousePos(evt);
    for(var i = 0; i < graphs.length; i++) {
        if( pointInRect(p, graphs[i].rect) ) {
            p = applyLinearTransformInverse(p, graphs[i].transform);
            var delta_acceleration = g - graphs[i].frame_acceleration
            p = transformBetweenAcceleratingReferenceFrames(p, delta_acceleration)
            trajectories[0].start = p;
            draw();
            break;
        }
    }
}

function clientToCanvas( clientPos ) {
    var rect = canvas.getBoundingClientRect();
    return pos( clientPos.x - rect.left, clientPos.y - rect.top );
}

function getMousePos(evt) {
    var rect = canvas.getBoundingClientRect();
    return pos( evt.clientX - rect.left, evt.clientY - rect.top );
}

function pointInRect( p, rect ) {
    var left = Math.min(rect.x, rect.x + rect.width);
    var right = Math.max(rect.x, rect.x + rect.width);
    var top = Math.min(rect.y, rect.y + rect.height);
    var bottom = Math.max(rect.y, rect.y + rect.height);
    return p.x > left && p.x < right && p.y > top && p.y < bottom;
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    isDragging = false;

    g = 9.8; // metres per second per second

    var timeTranslationSlider = document.getElementById("timeTranslationSlider");
    var timeTranslation = 2 - 4 * timeTranslationSlider.value / 100.0;
    time_range = range(-4 + timeTranslation, 4 + timeTranslation, 1);
    timeTranslationSlider.oninput = function() {
        var timeTranslation = 2 - 4 * timeTranslationSlider.value / 100.0;
        time_range = range(-4 + timeTranslation, 4 + timeTranslation, 1);
        for(var i = 0; i < graphs.length; i++) {
            updateGraphTransform(graphs[i]);
        }
        draw();
    }

    space_range = range(0, 50, 10);

    trajectories = [];
    trajectories.push(trajectory(pos(0.0, 44.1), pos(3.0, 0.0), 'rgb(255,100,100)'));
    trajectories.push(trajectory(pos(-1.0, 0.0), pos(2.0, 0.0), 'rgb(0,200,0)'));
    trajectories.push(trajectory(pos(-3.0, 0.0), pos(1.0, 0.0), 'rgb(100,100,255)'));
    
    graphs = [];
    graphs.push(graph(rect(40,440,400,-400), g));
    graphs.push(graph(rect(480,440,400,-400), g/2));
    graphs.push(graph(rect(920,440,400,-400), 0.0));

    var frameAccelerationSlider = document.getElementById("frameAccelerationSlider");
    graphs[1].frame_acceleration = g - g * frameAccelerationSlider.value / 100.0;
    frameAccelerationSlider.oninput = function() {
        graphs[1].frame_acceleration = g - g * this.value / 100.0;
        updateGraphTransform(graphs[1]);
        draw();
    }

    draw();

    canvas.addEventListener( 'mousemove',   onMouseMove, false );
    canvas.addEventListener( 'touchmove',   onTouchMove, false );

    canvas.addEventListener( 'mousedown',   onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
}

function draw() {
    // fill canvas with light gray
    ctx.fillStyle = 'rgb(240,240,240)';
    ctx.beginPath();
    ctx.rect(0,0,canvas.width, canvas.height);
    ctx.fill();

    // draw each graph
    for(var i = 0; i < graphs.length; i++) {
        drawSpaceTime(graphs[i]);
    }
}

function updateGraphTransform(graph) {
    graph.transform = findBestFitTransform(graph.rect, graph.frame_acceleration);
}

function drawSpaceTime(graph) {
    ctx.save(); // save the clip region for the moment

    // fill background with white
    ctx.fillStyle = 'rgb(255,255,255)';
    ctx.beginPath();
    ctx.rect(graph.rect.x, graph.rect.y, graph.rect.width, graph.rect.height);
    ctx.fill();
    ctx.clip(); // clip to this rect until reset

    // draw minor axes
    ctx.strokeStyle = 'rgb(240,240,240)';
    var space_extra = 80; // extend space axes beyond just the minimum area
    for(var t = Math.ceil(time_range.min); t<=Math.floor(time_range.max); t+=time_range.step) {
        if(t==0.0) { continue; }
        drawCurvingLine(pos(t, space_range.min-space_extra), pos(t, space_range.max+space_extra), graph.frame_acceleration, graph.transform);
    }
    for(var s = Math.ceil(space_range.min-space_extra); s<=Math.floor(space_range.max+space_extra); s+=space_range.step) {
        if(s==0.0) { continue; }
        drawCurvingLine(pos(time_range.min, s), pos(time_range.max, s), graph.frame_acceleration, graph.transform);
    }
    // draw major axes
    ctx.strokeStyle = 'rgb(100,100,100)';
    drawCurvingLine(pos(time_range.min, 0.0), pos(time_range.max, 0.0), graph.frame_acceleration, graph.transform);
    drawCurvingLine(pos(0.0, space_range.min-space_extra), pos(0.0, space_range.max+space_extra), graph.frame_acceleration, graph.transform);
    // draw trajectories in free-fall
    for(var i = 0; i < trajectories.length; i++) {
        ctx.strokeStyle = trajectories[i].color;
        ctx.fillStyle = trajectories[i].color;
        ctx.lineWidth = 2;
        drawGeodesic(trajectories[i].start, trajectories[i].end, graph.frame_acceleration, graph.transform);
    }
    
    // label axes
    ctx.fillStyle = 'rgb(100,100,100)';
    ctx.font = "13px Arial";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    var horizOffset = -0.1;
    textLabel(pos(horizOffset, 40.0), "40m", graph.frame_acceleration, graph.transform);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    var vertOffset = -0.4; 
    for(var t = Math.ceil(time_range.min); t<=Math.floor(time_range.max); t+=time_range.step) {
        textLabel(pos(t, vertOffset), t.toFixed(0)+"s", graph.frame_acceleration, graph.transform);
    }
    ctx.restore(); // reset the clip

    // show the frame acceleration as text
    ctx.fillStyle = 'rgb(0,0,0)';
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Frame acceleration = "+graph.frame_acceleration.toFixed(2)+" ms"+String.fromCharCode(0x207B)+String.fromCharCode(0x00B2),
        graph.rect.x+graph.rect.width/2, graph.rect.y+25);
}

function textLabel(p, text, frame_acceleration, transform) {
    var delta_acceleration = frame_acceleration - g;
    p = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(p, delta_acceleration), transform);
    ctx.fillText(text, p.x, p.y);
}

function drawCurvingLine(p1, p2, frame_acceleration, transform) {
    // draw a line that is straight in our familiar (accelerating upwards at g) reference frame but may not be straight in this frame, depending on its acceleration
    var delta_acceleration = frame_acceleration - g;
    drawLine(p1, p2, delta_acceleration, transform);
}

function drawGeodesic(p1, p2, frame_acceleration, transform) {
    // draw a line that is straight in an inertial frame but may be not be straight in this frame, depending on its acceleration

    // convert spacetime coordinates from our familiar (g-accelerating) frame into the inertial frame
    var delta_acceleration = 0.0 - g;
    var start = transformBetweenAcceleratingReferenceFrames(p1, delta_acceleration)
    var end = transformBetweenAcceleratingReferenceFrames(p2, delta_acceleration)
    // step along that line, converting to the target frame
    delta_acceleration = frame_acceleration - 0.0;
    drawLine(start, end, delta_acceleration, transform);
    // draw circles along the way
    var n_steps = 10;
    for(var i = 0; i <= n_steps; i++) {
        var u = i / n_steps;
        var c = lerp(start, end, u);
        c = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(c, delta_acceleration), transform);
        ctx.beginPath();
        var r = 2.0;
        if(i==0) { r = 6.0; } else if(i==n_steps) { r=4.0; }
        ctx.arc(c.x, c.y, r, 0, 2 * Math.PI);
        ctx.fill();
    }
    // draw an arrowhead to indicate the direction of travel
    var a1 = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(lerp(start, end, 0.59), delta_acceleration), transform);
    var a2 = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(lerp(start, end, 0.60), delta_acceleration), transform);
    drawArrowHead(a1, a2, 15);
}

function drawLine(p1, p2, delta_acceleration, transform) {
    // step along the line, converting to the target frame
    ctx.beginPath();
    var n_steps = 100;
    for(var i = 0; i <= n_steps; i++) {
        var u = i / n_steps;
        var ts = lerp(p1, p2, u);
        var p = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration), transform);
        if(i==0) {
            moveTo(p);
        }
        else {
            lineTo(p);
        }
    }
    ctx.stroke();
}

function transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration) {
    var t_zero = (time_range.min+time_range.max)/2; // central time point (e.g. t=0) gets no spatial distortion
    var time_delta = ts.x - t_zero;
    var x = ts.x;
    var y = ts.y - distanceTravelled(time_delta, delta_acceleration);
    return pos(x, y);
}


function findBestFitTransform(screen_rect, frame_acceleration) {
    var delta_acceleration = frame_acceleration - g;
    // plot some points in some arbitrary space then scale to fit the rect
    corners = [];
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.min, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.min, space_range.max), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.max, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.max, space_range.max), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos((time_range.min+time_range.max)/2, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos((time_range.min+time_range.max)/2, space_range.max), delta_acceleration));
    original_rect = boundingRect(corners);
    var adjusted_screen_rect = rect(screen_rect.x, screen_rect.y-20, screen_rect.width, screen_rect.height+20); // allow room for labels at the bottom
    return computeLinearTransform(original_rect, adjusted_screen_rect);
}

function distanceTravelled(time, acceleration) {
    return 0.5 * acceleration * time * time;
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
.frameAccelerationSlider {
  width: 25%;
  margin: auto;
}

.timeTranslationSlider {
  width: 25%;
  margin: auto;
}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 25px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}

.sansserif {
  font-family: Arial, Helvetica, sans-serif;
}

.text {
  width: 50%;
}

</style>

</head>

<body class="sansserif">
<p align="center">
<canvas class="canvas" id="canvas" width="1360" height="480">(Canvas drawing not supported by your browser.)</canvas>
<div class="frameAccelerationSlider">
  Change the frame acceleration: <input type="range" min="0" max="100" value="50" class="slider" id="frameAccelerationSlider">
</div>
<div class="timeTranslationSlider">
  Move the time window: <input type="range" min="0" max="100" value="50" class="slider" id="timeTranslationSlider">
</div>
</p>

<h4>Description:</h4>
<p class="text">
Under general relativity, gravity is not a force. Instead it is a distortion of spacetime. Objects in free-fall move along geodesics (straight lines) in spacetime, as seen in the inertial frame of reference on the right. When standing on Earth we experience a frame of reference that is accelerating upwards, causing objects in free-fall to move along parabolas, as seen in the accelerating frame of reference on the left.
</p>

<p class="text">
In this system there is only one space dimension, shown on the vertical axis and labeled in meters. The time dimension is the horizontal axis and labeled in seconds.
</p>

<p class="text">
Use the first slider to change the acceleration of the frame of reference in the middle. When the frame has zero acceleration it is said to be an inertial frame of reference.
</p>

<p class="text">
Use the second slider to move the time window. Note that all the trajectories remain as straight lines in the inertial frame of reference. 
</p>

<p class="text">
Code, more details, feedback: <a href="https://github.com/timhutton/GravityIsNotAForce">https://github.com/timhutton/GravityIsNotAForce</a>
</p>
</body>

</html>

