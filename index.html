<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

<!-- Visualisation of 1+1 spacetime -->

var currentTime;
var isAnimating;
var objects;
var g;
var frameAcceleration;
var time_range;
var space_range;

// classes:

function pos(x, y) {
    return { x:x, y:y };
}

function rect(x, y, width, height) {
    return { x:x, y:y, width:width, height:height };
}

function range(min, max, step=1.0) {
    return { min:min, max:max, step:step };
}

function object(start, end) {
    return { start:start, end:end };
}

function linearTransform(mult_x, offset_x, mult_y, offset_y) {
    return { mult_x:mult_x, offset_x:offset_x, mult_y:mult_y, offset_y:offset_y };
}

// functions:

function lerp(a, b, u) {
    return pos(a.x + u*(b.x-a.x), a.y + u*(b.y-a.y));
}

function moveTo(p) {
    ctx.moveTo(p.x, p.y);
}

function lineTo(p) {
    ctx.lineTo(p.x, p.y);
}

function applyLinearTransform(p, transform) {
    return pos(transform.offset_x + transform.mult_x*p.x, transform.offset_y + transform.mult_y*p.y);
}

function computeLinearTransform(from_rect, to_rect) {
    mult_x = to_rect.width / from_rect.width;
    offset_x = to_rect.x - mult_x * from_rect.x;
    mult_y = to_rect.height / from_rect.height;
    offset_y = to_rect.y - mult_y * from_rect.y;
    return linearTransform(mult_x, offset_x, mult_y, offset_y);
}

function boundingRect(points) {
    var left = Number.MAX_VALUE;
    var right = -Number.MAX_VALUE;
    var top = Number.MAX_VALUE;
    var bottom = -Number.MAX_VALUE;
    for(var i = 0; i < points.length; i++) {
        left = Math.min(left, points[i].x);
        right = Math.max(right, points[i].x);
        top = Math.min(top, points[i].y);
        bottom = Math.max(bottom, points[i].y);
    }
    return rect(left, top, right-left, bottom-top);
}

function onMouseMove( evt ) {
}

function onTouchMove( evt ) {
    evt.preventDefault();
}

function onTouchStart( evt ) {
}

function onMouseDown( evt ) {
}

function clientToCanvas( clientPos ) {
    var rect = canvas.getBoundingClientRect();
    return p2( clientPos.x - rect.left, clientPos.y - rect.top );
}

function pointInRect( p, rect ) {
    return p.x > rect.x && p.x < ( rect.x + rect.width ) &&
           p.y > rect.y && p.y < ( rect.y + rect.height );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    g = 9.8; // metres per second per second
    
    var frameAccelerationSlider = document.getElementById("frameAccelerationSlider");
    frameAcceleration = g - g * frameAccelerationSlider.value / 100.0;
    frameAccelerationSlider.oninput = function() {
        frameAcceleration = g - g * this.value / 100.0;
        draw();
    }

    var timeTranslationSlider = document.getElementById("timeTranslationSlider");
    var timeTranslation = -2 + 4 * timeTranslationSlider.value / 100.0;
    time_range = range(-4 + timeTranslation, 4 + timeTranslation, 1);
    timeTranslationSlider.oninput = function() {
        var timeTranslation = -2 + 4 * timeTranslationSlider.value / 100.0;
        time_range = range(-4 + timeTranslation, 4 + timeTranslation, 1);
        draw();
    }

    space_range = range(0, 50, 10);

    currentTime = 0.0;
    isAnimating = false;

    objects = [];
    objects.push(object(pos(0.0, 44.1), pos(3.0, 0.0)));
    objects.push(object(pos(-1.0, 0.0), pos(2.0, 0.0)));
    objects.push(object(pos(-3.0, 0.0), pos(1.0, 0.0)));

    draw();

    canvas.addEventListener( 'mousemove',   onMouseMove, false );
    canvas.addEventListener( 'touchmove',   onTouchMove, false );

    canvas.addEventListener( 'mousedown',   onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );

    animate();
}

function draw() {
    // fill canvas with light gray
    ctx.fillStyle = 'rgb(240,240,240)';
    ctx.beginPath();
    ctx.rect(0,0,canvas.width, canvas.height);
    ctx.fill();

    // draw each graph
    drawSpaceTime(rect(40,440,400,-400), g);
    drawSpaceTime(rect(480,440,400,-400), frameAcceleration);
    drawSpaceTime(rect(920,440,400,-400), 0.0);
}

function drawSpaceTime(screen_rect, frame_acceleration) {
    ctx.save(); // save the clip region for the moment

    // fill background with white
    ctx.fillStyle = 'rgb(255,255,255)';
    ctx.beginPath();
    ctx.rect(screen_rect.x, screen_rect.y, screen_rect.width, screen_rect.height);
    ctx.fill();
    ctx.clip(); // clip to this rect until reset

    var transform = findBestFitTransform(screen_rect, frame_acceleration);
    // draw minor axes
    ctx.strokeStyle = 'rgb(200,200,200)';
    for(var t = Math.ceil(time_range.min); t<=Math.floor(time_range.max); t+=time_range.step) {
        if(t==0.0) { continue; }
        drawCurvingLine(pos(t, space_range.min), pos(t, space_range.max), frame_acceleration, transform);
    }
    for(var s = Math.ceil(space_range.min); s<=Math.floor(space_range.max); s+=space_range.step) {
        if(s==0.0) { continue; }
        drawCurvingLine(pos(time_range.min, s), pos(time_range.max, s), frame_acceleration, transform);
    }
    // draw major axes
    ctx.strokeStyle = 'rgb(100,100,100)';
    drawCurvingLine(pos(time_range.min, 0.0), pos(time_range.max, 0.0), frame_acceleration, transform);
    drawCurvingLine(pos(0.0, space_range.min), pos(0.0, space_range.max), frame_acceleration, transform);
    // draw objects in free-fall
    ctx.strokeStyle = 'rgb(255,100,100)';
    for(var i = 0; i < objects.length; i++) {
        drawGeodesic(objects[i].start, objects[i].end, frame_acceleration, transform);
    }
        
    ctx.restore(); // reset the clip

    // show the frame acceleration as text
    ctx.fillStyle = 'rgb(0,0,0)';
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Frame acceleration = "+frame_acceleration.toFixed(2)+" ms"+String.fromCharCode(0x207B)+String.fromCharCode(0x00B2),
        screen_rect.x+screen_rect.width/2, screen_rect.y+25);
}

function drawCurvingLine(p1, p2, frame_acceleration, transform) {
    // draw a line that is straight in our familiar (accelerating upwards at g) reference frame but may not be straight in this frame, depending on its acceleration
    var delta_acceleration = frame_acceleration - g;
    ctx.beginPath();
    var step = 0.01;
    for(var u = 0.0; u < 1.0+step; u += step) {
        var ts = lerp(p1, p2, u);
        var p = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration), transform);
        if(u==0.0) {
            moveTo(p);
        }
        else {
            lineTo(p);
        }
    }
    ctx.stroke();
}

function drawGeodesic(p1, p2, frame_acceleration, transform) {
    // draw a line that is straight in an inertial frame but may be not be straight in this frame, depending on its acceleration

    // convert spacetime coordinates from our familiar (g-accelerating) frame into the inertial frame
    var delta_acceleration = 0.0 - g;
    var start = transformBetweenAcceleratingReferenceFrames(p1, delta_acceleration)
    var end = transformBetweenAcceleratingReferenceFrames(p2, delta_acceleration)
    // step along that line, converting to the target frame
    delta_acceleration = frame_acceleration - 0.0;
    ctx.beginPath();
    var step = 0.01;
    for(var u = 0.0; u < 1.0+step; u += step) {
        var ts = lerp(start, end, u);
        var p = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration), transform);
        if(u==0.0) {
            moveTo(p);
        }
        else {
            lineTo(p);
        }
    }
    ctx.stroke();
}

function transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration) {
    var t_zero = (time_range.min+time_range.max)/2; // central time point (e.g. t=0) gets no spatial distortion
    var time_delta = ts.x - t_zero;
    var x = ts.x;
    var y = ts.y - distanceTravelled(time_delta, delta_acceleration);
    return pos(x, y);
}


function findBestFitTransform(screen_rect, frame_acceleration) {
    var delta_acceleration = frame_acceleration - g;
    // plot some points in some arbitrary space then scale to fit the rect
    corners = [];
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.min, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.min, space_range.max), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.max, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.max, space_range.max), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos((time_range.min+time_range.max)/2, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos((time_range.min+time_range.max)/2, space_range.max), delta_acceleration));
    original_rect = boundingRect(corners);
    return computeLinearTransform(original_rect, screen_rect);
}

function distanceTravelled(time, acceleration) {
    return 0.5 * acceleration * time * time;
}

function animate() {
    if( isAnimating ) {
        currentTime = currentTime + 0.01;
        draw();
        requestAnimationFrame( animate );
    }
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
.frameAccelerationSlider {
  width: 25%;
  margin: auto;
}

.timeTranslationSlider {
  width: 25%;
}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 25px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}

.sansserif {
  font-family: Arial, Helvetica, sans-serif;
}

</style>

</head>

<body class="sansserif">
<p align="center">
<canvas class="canvas" id="canvas" width="1360" height="480">(Canvas drawing not supported by your browser.)</canvas>
<div class="frameAccelerationSlider">
  <input type="range" min="0" max="100" value="50" class="slider" id="frameAccelerationSlider">
</div>
</p>

<p>
<div class="timeTranslationSlider">
  Translate time window: <input type="range" min="0" max="100" value="50" class="slider" id="timeTranslationSlider">
</div>
</p>

<h4>About:</h4>
<p>
Work in progress.
</p>

<p>
Code: <a href="https://github.com/timhutton/GravityIsNotAForce">https://github.com/timhutton/GravityIsNotAForce</a>
</p>
</body>

</html>

