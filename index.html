<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

<!-- Visualisation of 1+1 spacetime -->

var currentTime;
var isAnimating;
var trajectories;
var g;
var frameAcceleration;
var time_range;
var space_range;

// classes:

function pos(x, y) {
    return { x:x, y:y };
}

function rect(x, y, width, height) {
    return { x:x, y:y, width:width, height:height };
}

function range(min, max, step=1.0) {
    return { min:min, max:max, step:step };
}

function trajectory(start, end, color) {
    return { start:start, end:end, color:color };
}

function linearTransform(mult_x, offset_x, mult_y, offset_y) {
    return { mult_x:mult_x, offset_x:offset_x, mult_y:mult_y, offset_y:offset_y };
}

// functions:

function lerp(a, b, u) {
    return pos(a.x + u*(b.x-a.x), a.y + u*(b.y-a.y));
}

function moveTo(p) {
    ctx.moveTo(p.x, p.y);
}

function lineTo(p) {
    ctx.lineTo(p.x, p.y);
}

function applyLinearTransform(p, transform) {
    return pos(transform.offset_x + transform.mult_x*p.x, transform.offset_y + transform.mult_y*p.y);
}

function computeLinearTransform(from_rect, to_rect) {
    mult_x = to_rect.width / from_rect.width;
    offset_x = to_rect.x - mult_x * from_rect.x;
    mult_y = to_rect.height / from_rect.height;
    offset_y = to_rect.y - mult_y * from_rect.y;
    return linearTransform(mult_x, offset_x, mult_y, offset_y);
}

function boundingRect(points) {
    var left = Number.MAX_VALUE;
    var right = -Number.MAX_VALUE;
    var top = Number.MAX_VALUE;
    var bottom = -Number.MAX_VALUE;
    for(var i = 0; i < points.length; i++) {
        left = Math.min(left, points[i].x);
        right = Math.max(right, points[i].x);
        top = Math.min(top, points[i].y);
        bottom = Math.max(bottom, points[i].y);
    }
    return rect(left, top, right-left, bottom-top);
}

function onMouseMove( evt ) {
}

function onTouchMove( evt ) {
}

function onTouchStart( evt ) {
}

function onMouseDown( evt ) {
}

function clientToCanvas( clientPos ) {
    var rect = canvas.getBoundingClientRect();
    return p2( clientPos.x - rect.left, clientPos.y - rect.top );
}

function pointInRect( p, rect ) {
    return p.x > rect.x && p.x < ( rect.x + rect.width ) &&
           p.y > rect.y && p.y < ( rect.y + rect.height );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    g = 9.8; // metres per second per second

    var frameAccelerationSlider = document.getElementById("frameAccelerationSlider");
    frameAcceleration = g - g * frameAccelerationSlider.value / 100.0;
    frameAccelerationSlider.oninput = function() {
        frameAcceleration = g - g * this.value / 100.0;
        draw();
    }

    var timeTranslationSlider = document.getElementById("timeTranslationSlider");
    var timeTranslation = -2 + 4 * timeTranslationSlider.value / 100.0;
    time_range = range(-4 + timeTranslation, 4 + timeTranslation, 1);
    timeTranslationSlider.oninput = function() {
        var timeTranslation = -2 + 4 * timeTranslationSlider.value / 100.0;
        time_range = range(-4 + timeTranslation, 4 + timeTranslation, 1);
        draw();
    }

    space_range = range(0, 50, 10);

    currentTime = 0.0;
    isAnimating = false;

    trajectories = [];
    trajectories.push(trajectory(pos(0.0, 44.1), pos(3.0, 0.0), 'rgb(255,100,100)'));
    trajectories.push(trajectory(pos(-1.0, 0.0), pos(2.0, 0.0), 'rgb(0,200,0)'));
    trajectories.push(trajectory(pos(-3.0, 0.0), pos(1.0, 0.0), 'rgb(100,100,255)'));

    draw();

    canvas.addEventListener( 'mousemove',   onMouseMove, false );
    canvas.addEventListener( 'touchmove',   onTouchMove, false );

    canvas.addEventListener( 'mousedown',   onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );

    animate();
}

function draw() {
    // fill canvas with light gray
    ctx.fillStyle = 'rgb(240,240,240)';
    ctx.beginPath();
    ctx.rect(0,0,canvas.width, canvas.height);
    ctx.fill();

    // draw each graph
    drawSpaceTime(rect(40,440,400,-400), g);
    drawSpaceTime(rect(480,440,400,-400), frameAcceleration);
    drawSpaceTime(rect(920,440,400,-400), 0.0);
}

function drawSpaceTime(screen_rect, frame_acceleration) {
    ctx.save(); // save the clip region for the moment

    // fill background with white
    ctx.fillStyle = 'rgb(255,255,255)';
    ctx.beginPath();
    ctx.rect(screen_rect.x, screen_rect.y, screen_rect.width, screen_rect.height);
    ctx.fill();
    ctx.clip(); // clip to this rect until reset

    var transform = findBestFitTransform(screen_rect, frame_acceleration);
    // draw minor axes
    ctx.strokeStyle = 'rgb(200,200,200)';
    for(var t = Math.ceil(time_range.min); t<=Math.floor(time_range.max); t+=time_range.step) {
        if(t==0.0) { continue; }
        drawCurvingLine(pos(t, space_range.min), pos(t, space_range.max), frame_acceleration, transform);
    }
    for(var s = Math.ceil(space_range.min); s<=Math.floor(space_range.max); s+=space_range.step) {
        if(s==0.0) { continue; }
        drawCurvingLine(pos(time_range.min, s), pos(time_range.max, s), frame_acceleration, transform);
    }
    // draw major axes
    ctx.strokeStyle = 'rgb(100,100,100)';
    drawCurvingLine(pos(time_range.min, 0.0), pos(time_range.max, 0.0), frame_acceleration, transform);
    drawCurvingLine(pos(0.0, space_range.min), pos(0.0, space_range.max), frame_acceleration, transform);
    // draw trajectories in free-fall
    for(var i = 0; i < trajectories.length; i++) {
        ctx.strokeStyle = trajectories[i].color;
        ctx.lineWidth = 2;
        drawGeodesic(trajectories[i].start, trajectories[i].end, frame_acceleration, transform);
    }
    
    // label axes
    ctx.fillStyle = 'rgb(100,100,100)';
    ctx.font = "13px Arial";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    var horizOffset = -0.1;
    textLabel(pos(horizOffset, 40.0), "40m", frame_acceleration, transform);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    var vertOffset = -0.4; 
    for(var t = Math.ceil(time_range.min); t<=Math.floor(time_range.max); t+=time_range.step) {
        textLabel(pos(t, vertOffset), t.toFixed(0)+"s", frame_acceleration, transform);
    }
    ctx.restore(); // reset the clip

    // show the frame acceleration as text
    ctx.fillStyle = 'rgb(0,0,0)';
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Frame acceleration = "+frame_acceleration.toFixed(2)+" ms"+String.fromCharCode(0x207B)+String.fromCharCode(0x00B2),
        screen_rect.x+screen_rect.width/2, screen_rect.y+25);
}

function textLabel(p, text, frame_acceleration, transform) {
    var delta_acceleration = frame_acceleration - g;
    p = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(p, delta_acceleration), transform);
    ctx.fillText(text, p.x, p.y);
}

function drawCurvingLine(p1, p2, frame_acceleration, transform) {
    // draw a line that is straight in our familiar (accelerating upwards at g) reference frame but may not be straight in this frame, depending on its acceleration
    var delta_acceleration = frame_acceleration - g;
    ctx.beginPath();
    var step = 0.01;
    for(var u = 0.0; u < 1.0+step; u += step) {
        var ts = lerp(p1, p2, u);
        var p = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration), transform);
        if(u==0.0) {
            moveTo(p);
        }
        else {
            lineTo(p);
        }
    }
    ctx.stroke();
}

function drawGeodesic(p1, p2, frame_acceleration, transform) {
    // draw a line that is straight in an inertial frame but may be not be straight in this frame, depending on its acceleration

    // convert spacetime coordinates from our familiar (g-accelerating) frame into the inertial frame
    var delta_acceleration = 0.0 - g;
    var start = transformBetweenAcceleratingReferenceFrames(p1, delta_acceleration)
    var end = transformBetweenAcceleratingReferenceFrames(p2, delta_acceleration)
    // step along that line, converting to the target frame
    delta_acceleration = frame_acceleration - 0.0;
    ctx.beginPath();
    var step = 0.01;
    for(var u = 0.0; u < 1.0+step; u += step) {
        var ts = lerp(start, end, u);
        var p = applyLinearTransform(transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration), transform);
        if(u==0.0) {
            moveTo(p);
        }
        else {
            lineTo(p);
        }
    }
    ctx.stroke();
}

function transformBetweenAcceleratingReferenceFrames(ts, delta_acceleration) {
    var t_zero = (time_range.min+time_range.max)/2; // central time point (e.g. t=0) gets no spatial distortion
    var time_delta = ts.x - t_zero;
    var x = ts.x;
    var y = ts.y - distanceTravelled(time_delta, delta_acceleration);
    return pos(x, y);
}


function findBestFitTransform(screen_rect, frame_acceleration) {
    var delta_acceleration = frame_acceleration - g;
    // plot some points in some arbitrary space then scale to fit the rect
    corners = [];
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.min, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.min, space_range.max), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.max, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos(time_range.max, space_range.max), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos((time_range.min+time_range.max)/2, space_range.min), delta_acceleration));
    corners.push(transformBetweenAcceleratingReferenceFrames(pos((time_range.min+time_range.max)/2, space_range.max), delta_acceleration));
    original_rect = boundingRect(corners);
    var adjusted_screen_rect = rect(screen_rect.x, screen_rect.y-20, screen_rect.width, screen_rect.height-20); // allow room for labels at the bottom
    return computeLinearTransform(original_rect, adjusted_screen_rect);
}

function distanceTravelled(time, acceleration) {
    return 0.5 * acceleration * time * time;
}

function animate() {
    if( isAnimating ) {
        currentTime = currentTime + 0.01;
        draw();
        requestAnimationFrame( animate );
    }
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
.frameAccelerationSlider {
  width: 25%;
  margin: auto;
}

.timeTranslationSlider {
  width: 25%;
  margin: auto;
}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 25px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}

.sansserif {
  font-family: Arial, Helvetica, sans-serif;
}

.text {
  width: 50%;
}

</style>

</head>

<body class="sansserif">
<p align="center">
<canvas class="canvas" id="canvas" width="1360" height="480">(Canvas drawing not supported by your browser.)</canvas>
<div class="frameAccelerationSlider">
  Change the frame acceleration: <input type="range" min="0" max="100" value="50" class="slider" id="frameAccelerationSlider">
</div>
<div class="timeTranslationSlider">
  Move the time window: <input type="range" min="0" max="100" value="50" class="slider" id="timeTranslationSlider">
</div>
</p>

<h4>Description:</h4>
<p class="text">
Under general relativity, gravity is not a force. Instead it is a distortion of spacetime. Objects in free-fall move along geodesics (straight lines) in spacetime, as seen in the inertial frame of reference on the right. When standing on Earth we experience a frame of reference that is accelerating upwards, causing objects in free-fall to move along parabolas, as seen in the accelerating frame of reference on the left.
</p>

<p class="text">
In this system there is only one space dimension, shown on the vertical axis and labeled in meters. The time dimension is the horizontal axis and labeled in seconds.
</p>

<p class="text">
Use the first slider to change the acceleration of the frame of reference in the middle. When the frame has zero acceleration it is said to be an inertial frame of reference.
</p>

<p class="text">
Use the second slider to move the time window. Note that all the trajectories remain as straight lines in the inertial frame of reference. 
</p>

<p>
Code, more details, feedback: <a href="https://github.com/timhutton/GravityIsNotAForce">https://github.com/timhutton/GravityIsNotAForce</a>
</p>
</body>

</html>

